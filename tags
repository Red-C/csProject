!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ALLOC_H	alloc.h	2;"	d
AND	read-command.c	/^    AND,   \/\/ &&$/;"	e	enum:token_type	file:
AND_COMMAND	command-internals.h	/^    AND_COMMAND,         \/\/ A && B$/;"	e	enum:command_type
BACK_SLASH	read-command.c	/^	BACK_SLASH,$/;"	e	enum:token_type	file:
CC	Makefile	/^CC = gcc$/;"	m
CFLAGS	Makefile	/^CFLAGS = -g -Wall -Wextra -Wno-unused -Werror$/;"	m
COMMAND_H	command.h	2;"	d
COMMAND_INTERNALS_H	command-internals.h	3;"	d
COMMENT	read-command.c	/^	COMMENT, \/\/ #$/;"	e	enum:token_type	file:
DISTDIR	Makefile	/^DISTDIR = lab1-$(USER)$/;"	m
DIST_SOURCES	Makefile	/^DIST_SOURCES = \\$/;"	m
Dependent	execute-command_yi.c	/^int Dependent(command_t a, command_t b) \/\/return 1 if a b can't run together.$/;"	f
END_OF_FILE	read-command.c	/^	END_OF_FILE,$/;"	e	enum:token_type	file:
IN	read-command.c	/^	IN,    \/\/ <$/;"	e	enum:token_type	file:
LAB	Makefile	/^LAB = 1$/;"	m
LB	read-command.c	/^    LB,  \/\/ ( $/;"	e	enum:token_type	file:
LOCKER	main_2.c	/^locker* LOCKER;$/;"	v
LOCKER_H	locker.h	2;"	d
NEW_LINE	read-command.c	/^	NEW_LINE,$/;"	e	enum:token_type	file:
OR	read-command.c	/^	OR,	   \/\/ ||$/;"	e	enum:token_type	file:
OR_COMMAND	command-internals.h	/^    OR_COMMAND,          \/\/ A || B$/;"	e	enum:command_type
OUT	read-command.c	/^	OUT,   \/\/ >$/;"	e	enum:token_type	file:
PIPE	read-command.c	/^    PIPE,  \/\/ | $/;"	e	enum:token_type	file:
PIPE_COMMAND	command-internals.h	/^    PIPE_COMMAND,        \/\/ A | B$/;"	e	enum:command_type
QUEUE_H	queue.h	2;"	d
RB	read-command.c	/^	RB,   \/\/ )$/;"	e	enum:token_type	file:
RLOCK	locker.c	32;"	d	file:
RLOCK	main_2.c	84;"	d	file:
SEQ	read-command.c	/^    SEQ,   \/\/ \\n ;$/;"	e	enum:token_type	file:
SEQUENCE_COMMAND	command-internals.h	/^    SEQUENCE_COMMAND,    \/\/ A ; B$/;"	e	enum:command_type
SEQ_ENTER	read-command.c	/^	SEQ_ENTER$/;"	e	enum:token_type	file:
SIMPLE_COMMAND	command-internals.h	/^    SIMPLE_COMMAND,      \/\/ a simple command$/;"	e	enum:command_type
STREAM_BUFFER_SIZE	read-command.c	13;"	d	file:
SUBSHELL_COMMAND	command-internals.h	/^    SUBSHELL_COMMAND    \/\/ ( A )$/;"	e	enum:command_type
TESTS	Makefile	/^TESTS = $(wildcard test*.sh)$/;"	m
TEST_BASES	Makefile	/^TEST_BASES = $(subst .sh,,$(TESTS))$/;"	m
TIMETRASH_OBJECTS	Makefile	/^TIMETRASH_OBJECTS = $(subst .c,.o,$(TIMETRASH_SOURCES))$/;"	m
TIMETRASH_SOURCES	Makefile	/^TIMETRASH_SOURCES = \\$/;"	m
ThreadFunction	execute-command_yi.c	/^void * ThreadFunction(void* arg)$/;"	f
VECTOR_H	vector.h	2;"	d
VECTOR_INIT_CAP	vector.h	3;"	d
WLOCK	locker.c	33;"	d	file:
WLOCK	main_2.c	85;"	d	file:
WORD	read-command.c	/^	WORD,  \/\/ token	$/;"	e	enum:token_type	file:
_GNU_SOURCE	main_2.c	2;"	d	file:
_line	read-command.c	/^unsigned int _line = 0;$/;"	v
addtwolist	execute-command_yi.c	/^void addtwolist(struct list_word**a,struct list_word **b)$/;"	f
ar	test.c	/^		  int *ar;$/;"	m	struct:__anon2	file:
array	vector.h	/^	void** array;$/;"	m	struct:vector
b_pair	read-command.c	/^b_pair(token_type key, char* value)$/;"	f
bool	command.h	/^typedef int bool;$/;"	t
box	locker.h	/^typedef struct box $/;"	s
box	locker.h	/^} box;$/;"	t	typeref:struct:box
box	main_2.c	/^typedef struct box $/;"	s	file:
box	main_2.c	/^} box;$/;"	t	typeref:struct:box	file:
box_t	locker.h	/^typedef box* box_t;$/;"	t
box_t	main_2.c	/^typedef box* box_t;$/;"	t	file:
buffer	read-command.c	/^	char* buffer;				\/\/ start location of buffer, deallocate purpose$/;"	m	struct:command_stream	file:
build_I_O_set	main_2.c	/^build_I_O_set(command_t c, set *in, set *out)$/;"	f
build_I_O_set	main_temp.c	/^build_I_O_set(command_t c, struct fileSet *in, struct fileSet *out)$/;"	f
build_token_tree	read-command.c	/^command_stream_t build_token_tree(queue Q) {$/;"	f
cap	vector.h	/^	int cap;$/;"	m	struct:vector
check_nonnull	alloc.c	/^check_nonnull (void *p)$/;"	f	file:
checked_grow_alloc	alloc.c	/^checked_grow_alloc (void *ptr, size_t *size)$/;"	f
checked_malloc	alloc.c	/^checked_malloc (size_t size)$/;"	f
checked_realloc	alloc.c	/^checked_realloc (void *ptr, size_t size)$/;"	f
command	command-internals.h	/^    struct command *command[2];$/;"	m	union:command::__anon1	typeref:struct:command::__anon1::command
command	command-internals.h	/^struct command$/;"	s
command_compare	execute-command_yi.c	/^command_compare(struct list_word *first ,struct list_word * second)\/\/ 0 means have same word,  1 means otherwise$/;"	f
command_indented_print	print-command.c	/^command_indented_print (int indent, command_t c)$/;"	f	file:
command_queue	read-command.c	/^	command_t* command_queue;	\/\/ complete commands array$/;"	m	struct:command_stream	file:
command_status	execute-command.c	/^command_status (command_t c)$/;"	f
command_status	execute-command_yi.c	/^command_status (command_t c)$/;"	f
command_stream	read-command.c	/^struct command_stream {$/;"	s	file:
command_stream_t	command.h	/^typedef struct command_stream *command_stream_t;$/;"	t	typeref:struct:command_stream
command_t	command.h	/^typedef struct command *command_t;$/;"	t	typeref:struct:command
command_type	command-internals.h	/^enum command_type$/;"	g
create_locker	locker.c	/^create_locker(char** all_files, int n)$/;"	f
create_locker	main_2.c	/^create_locker(char** all_files, int n)$/;"	f
dequeue	read-command.c	/^queue dequeue(queue q)$/;"	f
destroy	read-command.c	/^queue destroy(queue q)$/;"	f
eat_newline	read-command.c	/^void eat_newline(queue *s) {$/;"	f
enqueue	read-command.c	/^queue enqueue(pair* in, queue q)$/;"	f
exec_and	execute-command_yi.c	/^exec_and(command_t comm , int init)$/;"	f
exec_or	execute-command_yi.c	/^exec_or(command_t comm, int init)$/;"	f
exec_pipe	execute-command_yi.c	/^exec_pipe(command_t comm, int init)$/;"	f
exec_seq	execute-command_yi.c	/^exec_seq(command_t comm , int init)$/;"	f
exec_simple	execute-command_yi.c	/^exec_simple( command_t comm, int init) \/\/ just put init as 0$/;"	f
exec_sub	execute-command_yi.c	/^exec_sub(command_t comm, int init)$/;"	f
execute	main_2.c	/^execute(void* cmd) {$/;"	f
execute	main_temp.c	/^execute(void* cmd) {$/;"	f
execute_andor_command	execute-command.c	/^int execute_andor_command(command_t c) {$/;"	f
execute_command	execute-command.c	/^execute_command (command_t c, int time_travel)$/;"	f
execute_command	execute-command_yi.c	/^execute_command (command_t c, int time_travel)$/;"	f
execute_pipe_command	execute-command.c	/^int execute_pipe_command(command_t c)$/;"	f
execute_pipe_helper	execute-command.c	/^int execute_pipe_helper(command_t c, int i)$/;"	f
execute_simple_command	execute-command.c	/^execute_simple_command ( command_t c)$/;"	f
execute_subshell	execute-command.c	/^int execute_subshell(command_t c) {$/;"	f
execute_subshell_helper	execute-command.c	/^int execute_subshell_helper(command_t c) {$/;"	f
false	command.h	11;"	d
filename	locker.h	/^	char* filename;$/;"	m	struct:box
filename	main_2.c	/^	char* filename;$/;"	m	struct:box	file:
find_and_delete	vector.h	/^void find_and_delete(vector* v, void* node) {$/;"	f
generate_file_indexes	main_2.c	/^generate_file_indexes(command_t cmd,set* in, set *out, set *set) $/;"	f
get_locks	locker.c	/^get_locks(locker* L, int* r_locker_id, int n, int* w_locker_id, int m) {$/;"	f
get_locks	main_2.c	/^get_locks(locker* L, int* r_locker_id, int n, int* w_locker_id, int m) {$/;"	f
get_next_byte	main.c	/^get_next_byte (void *stream)$/;"	f	file:
get_next_byte	main_2.c	/^get_next_byte (void *stream)$/;"	f	file:
get_next_byte	main_temp.c	/^get_next_byte (void *stream)$/;"	f	file:
head	queue.h	/^	queue_node* head;$/;"	m	struct:queue
head	read-command.c	/^	 struct node * head;$/;"	m	struct:queue	typeref:struct:queue::node	file:
incer	test.c	/^  incer(void *arg)$/;"	f
input	command-internals.h	/^  char *input;$/;"	m	struct:command
inputlist	execute-command_yi.c	/^struct list_word* inputlist(command_t c)$/;"	f
isChanged	main_2.c	/^	bool isChanged;$/;"	m	struct:locker	file:
isRegular	partition.c	/^int isRegular(char input)$/;"	f
isRegular	read-command.c	/^int isRegular(char input)$/;"	f
isSEQ	read-command.c	/^isSEQ(queue *s) $/;"	f
isWORDS	read-command.c	/^isWORDS(queue* s) $/;"	f
is_any_thread_finished	main_temp.c	/^volatile bool is_any_thread_finished = false;$/;"	v
is_dependency	main_temp.c	/^bool is_dependency(command_t cmd, struct fileSet* in, struct fileSet* out) {$/;"	f
is_wlocked	locker.h	/^	bool is_wlocked;$/;"	m	struct:box
is_wlocked	main_2.c	/^	bool is_wlocked;$/;"	m	struct:box	file:
isempty	read-command.c	/^bool isempty(const queue q)$/;"	f
item	queue.h	/^	void *item;$/;"	m	struct:queue_node
iterator	read-command.c	/^	int iterator;				\/\/ iterator$/;"	m	struct:command_stream	file:
key	read-command.c	/^	token_type key;$/;"	m	struct:pair	file:
lineError	partition.c	/^void lineError(int numLine)$/;"	f
lineError	read-command.c	/^void lineError(const char* msg)$/;"	f
list_word	execute-command_yi.c	/^struct list_word$/;"	s	file:
listeners	command-internals.h	/^  struct command** listeners;$/;"	m	struct:command	typeref:struct:command::command
load_in_out	read-command.c	/^load_in_out(queue *s, command_t cmd) {$/;"	f
locker	locker.h	/^typedef struct locker $/;"	s
locker	locker.h	/^} locker;$/;"	t	typeref:struct:locker
locker	main_2.c	/^typedef struct locker $/;"	s	file:
locker	main_2.c	/^} locker;$/;"	t	typeref:struct:locker	file:
main	main.c	/^main (int argc, char **argv)$/;"	f
main	main_2.c	/^main (int argc, char **argv)$/;"	f
main	main_temp.c	/^main (int argc, char **argv)$/;"	f
main	test.c	/^  int main(void)$/;"	f
make_command_stream	read-command.c	/^make_command_stream (int (*get_next_byte) (void *),$/;"	f
malloc_cmd	read-command.c	/^malloc_cmd()$/;"	f
memory_exhausted	alloc.c	/^memory_exhausted (int errnum)$/;"	f	file:
mutex_lock	locker.h	/^pthread_mutex_t mutex_lock = PTHREAD_MUTEX_INITIALIZER;$/;"	v
mutex_lock	main_2.c	/^pthread_mutex_t mutex_lock = PTHREAD_MUTEX_INITIALIZER;$/;"	v
n	locker.h	/^	int n;$/;"	m	struct:box
n	main_2.c	/^	int n;$/;"	m	struct:box	file:
n	test.c	/^		  long n;$/;"	m	struct:__anon2	file:
n_locks	locker.h	/^	int n_locks;$/;"	m	struct:locker
n_locks	main_2.c	/^	int n_locks;$/;"	m	struct:locker	file:
n_reading	locker.h	/^	volatile int n_reading;$/;"	m	struct:box
n_reading	main_2.c	/^	int n_reading;$/;"	m	struct:box	file:
n_waiting	command-internals.h	/^  int n_waiting;$/;"	m	struct:command
next	execute-command_yi.c	/^  struct list_word* next;$/;"	m	struct:list_word	typeref:struct:list_word::list_word	file:
next	queue.h	/^	struct queue_node *next;$/;"	m	struct:queue_node	typeref:struct:queue_node::queue_node
next	read-command.c	/^	 struct node * next; $/;"	m	struct:node	typeref:struct:node::node	file:
next	read-command.c	/^pair* next(const queue q)$/;"	f
next_token_type	read-command.c	/^next_token_type(queue* s)$/;"	f
node	read-command.c	/^struct node{$/;"	s	file:
output	command-internals.h	/^  char *output;$/;"	m	struct:command
outputlist	execute-command_yi.c	/^struct list_word* outputlist(command_t c)$/;"	f
pair	read-command.c	/^typedef struct pair {$/;"	s	file:
pair	read-command.c	/^} pair;$/;"	t	typeref:struct:pair	file:
partition	partition.c	/^queue partition(char* input)$/;"	f
partition	read-command.c	/^queue partition(char* input)$/;"	f
prefix_traversal	read-command.c	/^command_t* prefix_traversal(command_t root, size_t *i)$/;"	f
prefix_traversal_helper	read-command.c	/^command_t* prefix_traversal_helper(command_t* Q, command_t cmd, size_t *cap, size_t *i) {$/;"	f
print_command	print-command.c	/^print_command (command_t c)$/;"	f
print_locker	locker.c	/^void print_locker(locker* L) {$/;"	f
program_name	main.c	/^static char const *program_name;$/;"	v	file:
program_name	main_2.c	/^static char const *program_name;$/;"	v	file:
program_name	main_temp.c	/^static char const *program_name;$/;"	v	file:
q_empty	read-command.c	/^q_empty()$/;"	f
queue	queue.h	/^typedef struct queue $/;"	s
queue	queue.h	/^} queue;$/;"	t	typeref:struct:queue
queue	read-command.c	/^typedef struct queue{$/;"	s	file:
queue	read-command.c	/^} queue;$/;"	t	typeref:struct:queue	file:
queue_dequeue	queue.h	/^void* queue_dequeue(queue* Q)$/;"	f
queue_enqueue	queue.h	/^queue* queue_enqueue(queue* Q, void* item)$/;"	f
queue_free	queue.h	/^void queue_free(queue* Q)$/;"	f
queue_init	queue.h	/^queue* queue_init()$/;"	f
queue_isempty	queue.h	/^bool queue_isempty(queue* Q)$/;"	f
queue_node	queue.h	/^typedef struct queue_node $/;"	s
queue_node	queue.h	/^} queue_node;$/;"	t	typeref:struct:queue_node
queue_sizeof	queue.h	/^int queue_sizeof(queue* Q)$/;"	f
read_andor	read-command.c	/^read_andor(command_t holder, queue *s) $/;"	f
read_command_stream	read-command.c	/^read_command_stream (command_stream_t s)$/;"	f
read_lock	locker.c	28;"	d	file:
read_lock	main_2.c	80;"	d	file:
read_pipeline	read-command.c	/^read_pipeline(command_t holder, queue* s) $/;"	f
read_seq	read-command.c	/^read_seq(command_t holder, queue *s)$/;"	f
read_simple_command	read-command.c	/^read_simple_command( queue *s) $/;"	f
read_subshell	read-command.c	/^read_subshell(queue *s) $/;"	f
read_unlock	locker.c	30;"	d	file:
read_unlock	main_2.c	82;"	d	file:
rebuild	execute-command_yi.c	/^command_stream_t rebuild(command_stream_t s)$/;"	f
release_locks	locker.c	/^release_locks(locker* L, int* r_locker_id, int n, int* w_locker_id, int m) {$/;"	f
release_locks	main_2.c	/^release_locks(locker* L, int* r_locker_id, int n, int* w_locker_id, int m) {$/;"	f
root	read-command.c	/^	command_t root;				\/\/ root of tree$/;"	m	struct:command_stream	file:
running_list	main_temp.c	/^vector* running_list;$/;"	v
running_mutex	main_temp.c	/^pthread_mutex_t running_mutex = PTHREAD_MUTEX_INITIALIZER;$/;"	v
script_name	main.c	/^static char const *script_name;$/;"	v	file:
script_name	main_2.c	/^static char const *script_name;$/;"	v	file:
script_name	main_temp.c	/^static char const *script_name;$/;"	v	file:
set_read_lock	locker.c	26;"	d	file:
set_read_lock	main_2.c	78;"	d	file:
set_write_lock	locker.c	27;"	d	file:
set_write_lock	main_2.c	79;"	d	file:
size	queue.h	/^	int size;$/;"	m	struct:queue
size	read-command.c	/^	 unsigned int size;$/;"	m	struct:queue	file:
size	read-command.c	/^	size_t size;				\/\/ number of element in command_queue$/;"	m	struct:command_stream	file:
size	vector.h	/^	int size;$/;"	m	struct:vector
status	command-internals.h	/^  int status;$/;"	m	struct:command
storage	locker.h	/^	box** storage;$/;"	m	struct:locker
storage	main_2.c	/^	box** storage;$/;"	m	struct:locker	file:
string_compare	execute-command_yi.c	/^string_compare(char * a, char * b)$/;"	f
subarray	test.c	/^	  } subarray;$/;"	t	typeref:struct:__anon2	file:
subshell_command	command-internals.h	/^    struct command *subshell_command;$/;"	m	union:command::__anon1	typeref:struct:command::__anon1::command
tail	queue.h	/^	queue_node* tail;$/;"	m	struct:queue
tail	read-command.c	/^	 struct node * tail;$/;"	m	struct:queue	typeref:struct:queue::node	file:
timetravel_mode	execute-command_yi.c	/^timetravel_mode(command_stream_t s)$/;"	f
token_type	read-command.c	/^  } token_type;$/;"	t	typeref:enum:token_type	file:
token_type	read-command.c	/^typedef enum token_type $/;"	g	file:
true	command.h	12;"	d
type	command-internals.h	/^  enum command_type type;$/;"	m	struct:command	typeref:enum:command::command_type
u	command-internals.h	/^  } u;$/;"	m	struct:command	typeref:union:command::__anon1
usage	main.c	/^usage (void)$/;"	f	file:
usage	main_2.c	/^usage (void)$/;"	f	file:
usage	main_temp.c	/^usage (void)$/;"	f	file:
value	read-command.c	/^	 pair* value;$/;"	m	struct:node	file:
value	read-command.c	/^	char* value;$/;"	m	struct:pair	file:
vector	vector.h	/^typedef struct vector {$/;"	s
vector	vector.h	/^} vector;$/;"	t	typeref:struct:vector
vector_delete	vector.h	/^void* vector_delete(vector* v, int i) {$/;"	f
vector_free	vector.h	/^void vector_free(vector* v)$/;"	f
vector_get	vector.h	/^void *vector_get(vector* v, int i)$/;"	f
vector_init	vector.h	/^vector *vector_init() {$/;"	f
vector_insert	vector.h	/^void vector_insert(vector* v, void* x)$/;"	f
vector_isempty	vector.h	/^bool vector_isempty(vector* v) {$/;"	f
vector_set	vector.h	/^void vector_set(vector* v, int i, void* n)$/;"	f
vector_sizeof	vector.h	30;"	d
word	command-internals.h	/^    char **word;$/;"	m	union:command::__anon1
word	execute-command_yi.c	/^  char* word;$/;"	m	struct:list_word	file:
write_lock	locker.c	29;"	d	file:
write_lock	main_2.c	81;"	d	file:
write_unlock	locker.c	31;"	d	file:
write_unlock	main_2.c	83;"	d	file:
