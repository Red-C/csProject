!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ALLOC_H	alloc.h	2;"	d
AND	read-command.c	/^    AND,   \/\/ &&$/;"	e	enum:token_type	file:
AND_COMMAND	command-internals.h	/^    AND_COMMAND,         \/\/ A && B$/;"	e	enum:command_type
BACK_SLASH	read-command.c	/^	BACK_SLASH,$/;"	e	enum:token_type	file:
CC	Makefile	/^CC = gcc$/;"	m
CFLAGS	Makefile	/^CFLAGS = -g -Wall -Wextra -Wno-unused -Werror$/;"	m
COMMAND_H	command.h	2;"	d
COMMAND_INTERNALS_H	command-internals.h	3;"	d
COMMENT	read-command.c	/^	COMMENT, \/\/ #$/;"	e	enum:token_type	file:
DISTDIR	Makefile	/^DISTDIR = lab1-$(USER)$/;"	m
DIST_SOURCES	Makefile	/^DIST_SOURCES = \\$/;"	m
END_OF_FILE	read-command.c	/^	END_OF_FILE,$/;"	e	enum:token_type	file:
IN	read-command.c	/^	IN,    \/\/ <$/;"	e	enum:token_type	file:
LAB	Makefile	/^LAB = 1$/;"	m
LB	read-command.c	/^    LB,  \/\/ ( $/;"	e	enum:token_type	file:
NEW_LINE	read-command.c	/^	NEW_LINE,$/;"	e	enum:token_type	file:
OR	read-command.c	/^	OR,	   \/\/ ||$/;"	e	enum:token_type	file:
OR_COMMAND	command-internals.h	/^    OR_COMMAND,          \/\/ A || B$/;"	e	enum:command_type
OUT	read-command.c	/^	OUT,   \/\/ >$/;"	e	enum:token_type	file:
PIPE	read-command.c	/^    PIPE,  \/\/ | $/;"	e	enum:token_type	file:
PIPE_COMMAND	command-internals.h	/^    PIPE_COMMAND,        \/\/ A | B$/;"	e	enum:command_type
RB	read-command.c	/^	RB,   \/\/ )$/;"	e	enum:token_type	file:
SEQ	read-command.c	/^    SEQ,   \/\/ \\n ;$/;"	e	enum:token_type	file:
SEQUENCE_COMMAND	command-internals.h	/^    SEQUENCE_COMMAND,    \/\/ A ; B$/;"	e	enum:command_type
SEQ_ENTER	read-command.c	/^	SEQ_ENTER$/;"	e	enum:token_type	file:
SIMPLE_COMMAND	command-internals.h	/^    SIMPLE_COMMAND,      \/\/ a simple command$/;"	e	enum:command_type
STREAM_BUFFER_SIZE	read-command.c	13;"	d	file:
SUBSHELL_COMMAND	command-internals.h	/^    SUBSHELL_COMMAND    \/\/ ( A )$/;"	e	enum:command_type
TESTS	Makefile	/^TESTS = $(wildcard test*.sh)$/;"	m
TEST_BASES	Makefile	/^TEST_BASES = $(subst .sh,,$(TESTS))$/;"	m
TIMETRASH_OBJECTS	Makefile	/^TIMETRASH_OBJECTS = $(subst .c,.o,$(TIMETRASH_SOURCES))$/;"	m
TIMETRASH_SOURCES	Makefile	/^TIMETRASH_SOURCES = \\$/;"	m
WORD	read-command.c	/^	WORD,  \/\/ token	$/;"	e	enum:token_type	file:
_line	read-command.c	/^unsigned int _line = 0;$/;"	v
b_pair	read-command.c	/^b_pair(token_type key, char* value)$/;"	f
bool	command.h	/^typedef int bool;$/;"	t
buffer	read-command.c	/^	char* buffer;				\/\/ start location of buffer, deallocate purpose$/;"	m	struct:command_stream	file:
build_token_tree	read-command.c	/^command_stream_t build_token_tree(queue Q) {$/;"	f
check_nonnull	alloc.c	/^check_nonnull (void *p)$/;"	f	file:
checked_grow_alloc	alloc.c	/^checked_grow_alloc (void *ptr, size_t *size)$/;"	f
checked_malloc	alloc.c	/^checked_malloc (size_t size)$/;"	f
checked_realloc	alloc.c	/^checked_realloc (void *ptr, size_t size)$/;"	f
command	command-internals.h	/^    struct command *command[2];$/;"	m	union:command::__anon1	typeref:struct:command::__anon1::command
command	command-internals.h	/^struct command$/;"	s
command_indented_print	print-command.c	/^command_indented_print (int indent, command_t c)$/;"	f	file:
command_queue	read-command.c	/^	command_t* command_queue;	\/\/ complete commands array$/;"	m	struct:command_stream	file:
command_status	execute-command.c	/^command_status (command_t c)$/;"	f
command_stream	read-command.c	/^struct command_stream {$/;"	s	file:
command_stream_t	command.h	/^typedef struct command_stream *command_stream_t;$/;"	t	typeref:struct:command_stream
command_t	command.h	/^typedef struct command *command_t;$/;"	t	typeref:struct:command
command_type	command-internals.h	/^enum command_type$/;"	g
dequeue	read-command.c	/^queue dequeue(queue q)$/;"	f
destroy	read-command.c	/^queue destroy(queue q)$/;"	f
eat_newline	read-command.c	/^void eat_newline(queue *s) {$/;"	f
enqueue	read-command.c	/^queue enqueue(pair* in, queue q)$/;"	f
execute_andor_command	execute-command.c	/^int execute_andor_command(command_t c) {$/;"	f
execute_command	execute-command.c	/^execute_command (command_t c, int time_travel)$/;"	f
execute_pipe_command	execute-command.c	/^int execute_pipe_command(command_t c)$/;"	f
execute_pipe_helper	execute-command.c	/^int execute_pipe_helper(command_t c, int i)$/;"	f
execute_simple_command	execute-command.c	/^execute_simple_command ( command_t c)$/;"	f
execute_subshell	execute-command.c	/^int execute_subshell(command_t c) {$/;"	f
execute_subshell_helper	execute-command.c	/^int execute_subshell_helper(command_t c) {$/;"	f
false	command.h	11;"	d
get_next_byte	main.c	/^get_next_byte (void *stream)$/;"	f	file:
head	read-command.c	/^	 struct node * head;$/;"	m	struct:queue	typeref:struct:queue::node	file:
input	command-internals.h	/^  char *input;$/;"	m	struct:command
isRegular	partition.c	/^int isRegular(char input)$/;"	f
isRegular	read-command.c	/^int isRegular(char input)$/;"	f
isSEQ	read-command.c	/^isSEQ(queue *s) $/;"	f
isWORDS	read-command.c	/^isWORDS(queue* s) $/;"	f
isempty	read-command.c	/^bool isempty(const queue q)$/;"	f
iterator	read-command.c	/^	int iterator;				\/\/ iterator$/;"	m	struct:command_stream	file:
key	read-command.c	/^	token_type key;$/;"	m	struct:pair	file:
lineError	partition.c	/^void lineError(int numLine)$/;"	f
lineError	read-command.c	/^void lineError(const char* msg)$/;"	f
load_in_out	read-command.c	/^load_in_out(queue *s, command_t cmd) {$/;"	f
main	main.c	/^main (int argc, char **argv)$/;"	f
make_command_stream	read-command.c	/^make_command_stream (int (*get_next_byte) (void *),$/;"	f
malloc_cmd	read-command.c	/^malloc_cmd()$/;"	f
memory_exhausted	alloc.c	/^memory_exhausted (int errnum)$/;"	f	file:
next	read-command.c	/^	 struct node * next; $/;"	m	struct:node	typeref:struct:node::node	file:
next	read-command.c	/^pair* next(const queue q)$/;"	f
next_token_type	read-command.c	/^next_token_type(queue* s)$/;"	f
node	read-command.c	/^struct node{$/;"	s	file:
output	command-internals.h	/^  char *output;$/;"	m	struct:command
pair	read-command.c	/^typedef struct pair {$/;"	s	file:
pair	read-command.c	/^} pair;$/;"	t	typeref:struct:pair	file:
partition	partition.c	/^queue partition(char* input)$/;"	f
partition	read-command.c	/^queue partition(char* input)$/;"	f
prefix_traversal	read-command.c	/^command_t* prefix_traversal(command_t root, size_t *i)$/;"	f
prefix_traversal_helper	read-command.c	/^command_t* prefix_traversal_helper(command_t* Q, command_t cmd, size_t *cap, size_t *i) {$/;"	f
print_command	print-command.c	/^print_command (command_t c)$/;"	f
program_name	main.c	/^static char const *program_name;$/;"	v	file:
q_empty	read-command.c	/^q_empty()$/;"	f
queue	read-command.c	/^typedef struct queue{$/;"	s	file:
queue	read-command.c	/^} queue;$/;"	t	typeref:struct:queue	file:
read_andor	read-command.c	/^read_andor(command_t holder, queue *s) $/;"	f
read_command_stream	read-command.c	/^read_command_stream (command_stream_t s)$/;"	f
read_pipeline	read-command.c	/^read_pipeline(command_t holder, queue* s) $/;"	f
read_seq	read-command.c	/^read_seq(command_t holder, queue *s)$/;"	f
read_simple_command	read-command.c	/^read_simple_command( queue *s) $/;"	f
read_subshell	read-command.c	/^read_subshell(queue *s) $/;"	f
root	read-command.c	/^	command_t root;				\/\/ root of tree$/;"	m	struct:command_stream	file:
script_name	main.c	/^static char const *script_name;$/;"	v	file:
size	read-command.c	/^	 unsigned int size;$/;"	m	struct:queue	file:
size	read-command.c	/^	size_t size;				\/\/ number of element in command_queue$/;"	m	struct:command_stream	file:
status	command-internals.h	/^  int status;$/;"	m	struct:command
subshell_command	command-internals.h	/^    struct command *subshell_command;$/;"	m	union:command::__anon1	typeref:struct:command::__anon1::command
tail	read-command.c	/^	 struct node * tail;$/;"	m	struct:queue	typeref:struct:queue::node	file:
token_type	read-command.c	/^  } token_type;$/;"	t	typeref:enum:token_type	file:
token_type	read-command.c	/^typedef enum token_type $/;"	g	file:
true	command.h	12;"	d
type	command-internals.h	/^  enum command_type type;$/;"	m	struct:command	typeref:enum:command::command_type
u	command-internals.h	/^  } u;$/;"	m	struct:command	typeref:union:command::__anon1
usage	main.c	/^usage (void)$/;"	f	file:
value	read-command.c	/^	 pair* value;$/;"	m	struct:node	file:
value	read-command.c	/^	char* value;$/;"	m	struct:pair	file:
word	command-internals.h	/^    char **word;$/;"	m	union:command::__anon1
